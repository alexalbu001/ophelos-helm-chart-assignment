# Production environment overrides
# Use: helm install voting-app ./voting-app-chart -f values-prod.yaml

global:
  environment: production
  labels:
    environment: production
    managed-by: helm

# Production-grade scaling
vote:
  replicaCount: 3
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 20
    targetCPUUtilizationPercentage: 70
  podDisruptionBudget:
    enabled: true
    minAvailable: 2
  # Anti-affinity to spread pods across nodes
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/component
              operator: In
              values:
              - vote
          topologyKey: kubernetes.io/hostname

  service:
    type: LoadBalancer
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-type: "alb"

result:
  replicaCount: 3
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 20
    targetCPUUtilizationPercentage: 70
  podDisruptionBudget:
    enabled: true
    minAvailable: 2
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/component
              operator: In
              values:
              - result
          topologyKey: kubernetes.io/hostname

  service:
    type: LoadBalancer
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-type: "alb"

worker:
  replicaCount: 3
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 75

redis:
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  persistence:
    enabled: true
    size: 10Gi
  auth:
    enabled: true
    existingSecret: "REDIS_AUTH" # to be created
    existingSecretPasswordKey: "REDIS_PASSWORD" # to be created

postgresql:
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 500m
      memory: 512Mi
  persistence:
    enabled: true
    size: 50Gi
  auth:
    # SECURITY: Use existing secret in production!
    existingSecret: "DB_AUTH" # to be created
    existingSecretPasswordKey: "DB_PASSWORD" # to be created
    existingSecretUsernameKey: "DB_USERNAME" # to be created

# Production ingress with TLS
features:
  ingress:
    enabled: true
    className: "nginx"
    annotations:
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/rate-limit: "100"
    hosts:
      vote:
        host: vote.example.com
        paths:
        - path: /
          pathType: Prefix
      result:
        host: result.example.com
        paths:
        - path: /
          pathType: Prefix
    tls:
    - secretName: voting-app-tls
      hosts:
      - vote.example.com
      - result.example.com

  monitoring:
    enabled: true

  networkPolicy:
    enabled: true

  podSecurityPolicy:
    enabled: true

# Stricter security in production
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

containerSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false

# Production-grade update strategy
updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0 # Zero downtime
